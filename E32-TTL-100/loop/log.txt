03/11/2019:
	Received RREQ:
		- check if received reversed path (ACK): [TODO] TURN OFF TIMER, no need to wait for ACK anymore
		- check if duplicate (received_broadcast_table[])
		- update received_broadcast_table
		[TODO]- check if destination -> yes, unicast RREP	
		- check if destination -> no:
			+ UNICAST ACK TO SENDER
			+ update routing table
			+ rebroadcast: hop_count++; sender_address: changed

03/12/2019:
	- fix LoRa_broadcast(); delete _E32_LoRa_broadcast();
	- add api: LoRa_unicast(), unicast_RREQ_ACK()
	- TEST: find sizeof(pointer)?
		uint8_t* message
		sizeof(message)?
		--> _sizeof(uint8_t* message);
	- change position of: check destination
	- unicast RREP to source: if received_broadcast: its address == RREQ.dest_address
	- [TODO] if received RREP_message
	
03/13/2019:
	- fix: increment sequence_number if unicast RREP_message, searching in routing_table
	- if received RREP_message:
		+ check if reversed_path (ACK): Yes-> TURN OFF TIMER, no need to wait for ACK anymore. 
		+ No-> unicast reversed_path (ACK) to send_from
		+ hop_count++
		+ update routing_table: check if exist in table: Yes-> update sequence_number (if >); No-> add new in routing_table
		+ Check if destination? If yes, do nothing
		+ If no, search in routing_table for next_hop to destination -> unicast RREP to next_hop -> wait for ACK
	- after receiving RREQ, if dest exists in routing_table -> forward to source
	- TEST: start/ stop timer
	- Turn off timer if received ACK; Continue to listen if receive NO ACK
	
		
